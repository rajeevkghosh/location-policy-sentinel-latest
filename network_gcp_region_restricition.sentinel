#This policy uses the Sentinel tfplan/v2 import to require that
# all GCE compute instances have all mandatory labels

# Note that the comparison is case-sensitive but also that GCE labels are only
# allowed to contain lowercase letters, numbers, hypens, and underscores.

# Import tfplan-functions.sentinel
# with alias "plan"
import "tfplan-functions" as plan
import "strings"
import "types"

prefix = "us-"
multi_region_var = ["US"]

# Resource Types Region Map
resourceTypesRegionMap = {

	"google_pubsub_topic": {
		"key":   "message_storage_policy.0.allowed_persistence_regions",
		"array": false,
	},
	"google_bigquery_dataset": {
		"key":   "location",
		"array": false,
	},
	"google_dataproc_cluster": {
		"key":   "region",
		"array": false,
	},
	"google_secret_manager_secret": {
		"key":   "replication.0.user_managed.0.replicas",
		"array": true,
	},
}

allResources = {}
for resourceTypesRegionMap as rt, _ {
	resources = plan.find_resources(rt)
	for resources as address, rc {
		allResources[address] = rc
	}
}

check_for_multilocation = func(location) {
	loca_multi = []
	for location as rt {
		a = plan.evaluate_attribute(rt, "location")
		append(loca_multi, a)
	}
	return loca_multi
}

check_for_location = func(address, rc, location_key_param, arr) {
	violations = {}
	locations = []
	location = plan.evaluate_attribute(rc.change.after, location_key_param)

	if arr == false {

		is_undefined = rule { types.type_of(location) is "undefined" }

		if is_undefined is true {

			#return violations
			violations[address] = rc

		} else {

			is_string = rule { types.type_of(location) is "string" }

			if is_string {

				append(locations, location)

			} else {

				locations = location
			}


			for locations as lk {
				print(lk)
				if strings.has_prefix(lk, prefix) or lk in multi_region_var {

				} else {

					violations[address] = rc

				}

			}
		}
		return violations
	} else {

		loca = check_for_multilocation(location)

		for loca as lk {
            print(lk)
			if strings.has_prefix(lk, prefix) or lk in multi_region_var {

			} else {

				violations[address] = rc

			}

		}

		return violations
	}
}

msgs = {}
for allResources as address, rc {
	msg = check_for_location(
		address,
		rc,
		resourceTypesRegionMap[rc["type"]]["key"],
		resourceTypesRegionMap[rc["type"]]["array"],
	)
	#print(msg)
	if length(msg) > 0 {
		msgs[address] = msg
	}
}

GCP_RES_LOCATION = rule { length(msgs) is 0 }

# Main rule
main = rule { GCP_RES_LOCATION }
